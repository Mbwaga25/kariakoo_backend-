# your_app/graphql/handlers/category_handler.py
from .base_handler import BaseHandler
from ..helpers import handle_image_import, get_or_create_related # Adjusted path
from ...models import ProductCategory # Adjusted path to app's models
from django.utils.text import slugify

class CategoryHandler(BaseHandler):
    model = ProductCategory
    required_fields = ['name']
    lookup_field = 'name'

    def handle(self, data):
        errors = []
        if not self.validate_data(data, errors):
            return {'instance': None, 'status': 'error', 'errors': errors}

        lookup_params, param_errors = self._get_lookup_params(data)
        if param_errors:
            return {'instance': None, 'status': 'error', 'errors': param_errors}

        category_name = lookup_params.get(self.lookup_field)

        # --- Handle Parent Category ---
        parent_instance = None
        parent_data = data.get('parent') # Parent data could be a name string or a dict {'name': 'Parent Name'}
        if parent_data:
            if not isinstance(parent_data, dict): # Assume it's a name if not a dict
                parent_data = {'name': parent_data}

            # Recursively handle the parent category using the same logic.
            # The create_related and update_existing flags are inherited.
            parent_handler = CategoryHandler(update_existing=self.update_existing, create_related=self.create_related)
            parent_result = parent_handler.handle(parent_data)

            if parent_result['instance']:
                parent_instance = parent_result['instance']
            else:
                # If parent processing had errors, append them and potentially stop.
                for err in parent_result['errors']:
                    errors.append(f"Parent category ('{parent_data.get('name', 'N/A')}') error: {err}")
                # If parent is crucial and couldn't be resolved, and creation not allowed, this category can't be processed.
                if not parent_instance and not self.create_related: # Check if parent was required and couldn't be made
                     errors.append(f"Parent category '{parent_data.get('name', 'N/A')}' could not be resolved and creation is disallowed.")
                     return {'instance': None, 'status': 'error', 'errors': errors}


        # Prepare defaults for creation or update
        defaults = {
            'description': data.get('description', ''),
            'parent': parent_instance,
            # slug is auto-generated by model's save method
        }

        image_data_input = data.get('image')
        if image_data_input:
            image_file = handle_image_import(image_data_input, f"category_{slugify(category_name if category_name else 'unknown')}")
            if image_file:
                defaults['image'] = image_file
            else:
                errors.append(f"Failed to process image for category '{category_name}'.")

        instance = None
        status = 'skipped'

        try:
            if self.update_existing:
                instance, created = self.model.objects.update_or_create(
                    defaults=defaults,
                    **lookup_params
                )
                status = 'created' if created else 'updated'
            else:
                try:
                    instance = self.model.objects.get(**lookup_params)
                    # Found, but not updating. Check if defaults need applying if instance exists.
                    # This part is tricky: if update_existing is False, should we update fields like description or parent?
                    # For now, we assume no update to existing fields if update_existing is False.
                except self.model.DoesNotExist:
                    if self.create_related: # This flag means "can we create this category?"
                        create_data = {**defaults, **lookup_params}
                        instance = self.model.objects.create(**create_data)
                        status = 'created'
                    else:
                        errors.append(f"{self.model.__name__} '{category_name}' not found, and creation is disallowed.")
                        status = 'error'
                except self.model.MultipleObjectsReturned:
                    errors.append(f"Multiple {self.model.__name__} instances found for '{category_name}'.")
                    status = 'error'

        except Exception as e:
            errors.append(f"Error processing {self.model.__name__} '{category_name}': {str(e)}")
            status = 'error'
            if instance:
                instance = None
        
        final_status = status
        if errors and status not in ['error', 'skipped']:
            final_status = 'completed_with_errors'


        return {'instance': instance, 'status': final_status, 'errors': errors}

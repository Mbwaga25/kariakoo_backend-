# your_app/graphql/handlers/tag_handler.py
from .base_handler import BaseHandler
from ...models import Tag # Adjusted path to app's models
from django.utils.text import slugify

class TagHandler(BaseHandler):
    model = Tag
    required_fields = ['name']
    lookup_field = 'name'

    def handle(self, data):
        errors = []
        if not self.validate_data(data, errors):
            return {'instance': None, 'status': 'error', 'errors': errors}

        lookup_params, param_errors = self._get_lookup_params(data)
        if param_errors:
            return {'instance': None, 'status': 'error', 'errors': param_errors}

        tag_name = lookup_params.get(self.lookup_field)

        # Defaults for creation or update. Slug is auto-generated by model's save if not provided.
        defaults = {}
        if 'slug' in data and data['slug']: # Allow explicit slug override
            defaults['slug'] = data['slug']
        # If no slug provided, model's save method will generate it from name.

        instance = None
        status = 'skipped'

        try:
            if self.update_existing:
                instance, created = self.model.objects.update_or_create(
                    defaults=defaults,
                    **lookup_params
                )
                status = 'created' if created else 'updated'
            else:
                try:
                    instance = self.model.objects.get(**lookup_params)
                    # Found, not updating.
                except self.model.DoesNotExist:
                    if self.create_related: # Can we create this tag?
                        create_data = {**defaults, **lookup_params}
                        instance = self.model.objects.create(**create_data)
                        status = 'created'
                    else:
                        errors.append(f"{self.model.__name__} '{tag_name}' not found, and creation is disallowed.")
                        status = 'error'
                except self.model.MultipleObjectsReturned:
                    errors.append(f"Multiple {self.model.__name__} instances found for '{tag_name}'.")
                    status = 'error'
        
        except Exception as e:
            errors.append(f"Error processing {self.model.__name__} '{tag_name}': {str(e)}")
            status = 'error'
            if instance:
                instance = None

        final_status = status
        if errors and status not in ['error', 'skipped']:
            final_status = 'completed_with_errors' # Should not happen for Tag if simple

        return {'instance': instance, 'status': final_status, 'errors': errors}

# your_app/graphql/handlers/product_segment_handler.py
from .base_handler import BaseHandler
from ...models import ProductSegment, Product # Adjusted path to app's models
# We'll use the get_or_create_related helper for resolving products for simplicity,
# as shown in your initial functional example for segments.
# A more complex setup might involve calling ProductHandler.
from ..helpers import get_or_create_related
from django.utils.text import slugify

class ProductSegmentHandler(BaseHandler):
    model = ProductSegment
    required_fields = ['title']
    lookup_field = 'title' # Segments will be looked up by their title

    def handle(self, data):
        """
        Handles the creation or update of a ProductSegment.
        - data: Dict containing segment data (e.g., 'title', 'slug', 'products' list, etc.).
        """
        errors = []
        if not self.validate_data(data, errors): # Validates 'title'
            return {'instance': None, 'status': 'error', 'errors': errors}

        lookup_params, param_errors = self._get_lookup_params(data)
        if param_errors:
            errors.extend(param_errors)
            return {'instance': None, 'status': 'error', 'errors': errors}

        segment_title = lookup_params.get(self.lookup_field)

        # Prepare defaults for creation or update of the segment itself
        segment_defaults = {
            # Slug is auto-generated by model's save method if not provided or if blank
            'slug': data.get('slug') or slugify(segment_title), 
            'is_active': data.get('is_active', True),
            'order': data.get('order', 0),
        }
        # Remove None values unless they are intended to clear a field (e.g. if slug could be cleared)
        # For this model, slug is usually mandatory or auto-generated if blank.
        segment_defaults = {k: v for k, v in segment_defaults.items() if v is not None or k == 'slug'}


        instance = None
        status = 'skipped' # Default status
        product_resolution_errors = [] # Specific errors from resolving associated products

        # --- Resolve Product instances for the M2M relationship ---
        product_instances_to_set = []
        # Expected: a list of product names or simple dicts like {'name': 'Product Name'}
        products_input_data = data.get('products', []) 

        if products_input_data is not None: # Process even if it's an empty list (to clear relations)
            for p_item_data in products_input_data:
                product_name_for_lookup = None
                if isinstance(p_item_data, dict):
                    product_name_for_lookup = p_item_data.get('name')
                elif isinstance(p_item_data, str): # Allows passing a list of product names
                    product_name_for_lookup = p_item_data
                
                if not product_name_for_lookup:
                    product_resolution_errors.append(
                        f"Invalid product identifier provided in 'products' list for segment '{segment_title}'."
                    )
                    continue

                # Using get_or_create_related to find/create product instances.
                # `self.create_related` determines if missing products can be created.
                # `self.update_existing` determines if found products can be updated (though defaults here are empty).
                product_instance, p_errs = get_or_create_related(
                    model=Product,
                    lookup_params={'name': product_name_for_lookup},
                    defaults={}, # No specific product details to update from segment data
                    create_if_missing=self.create_related,
                    update_existing_flag=self.update_existing 
                )
                
                if product_instance:
                    product_instances_to_set.append(product_instance)
                if p_errs:
                    for err_msg in p_errs:
                        product_resolution_errors.append(
                            f"Error resolving product '{product_name_for_lookup}' for segment '{segment_title}': {err_msg}"
                        )
            
            errors.extend(product_resolution_errors) # Add any product resolution errors to the main error list

        # --- Create or Update the ProductSegment instance ---
        try:
            if self.update_existing:
                instance, created = self.model.objects.update_or_create(
                    defaults=segment_defaults,
                    **lookup_params # e.g., title=segment_title
                )
                status = 'created' if created else 'updated'
            else: # Not updating existing segment's own fields
                try:
                    instance = self.model.objects.get(**lookup_params)
                    status = 'skipped' # Found, but not updating. M2M might still be processed.
                except self.model.DoesNotExist:
                    if self.create_related: # Can we create this new segment?
                        create_data = {**segment_defaults, **lookup_params}
                        instance = self.model.objects.create(**create_data)
                        status = 'created'
                    else:
                        errors.append(f"Segment '{segment_title}' not found, and creation is disallowed.")
                        status = 'error'
                except self.model.MultipleObjectsReturned:
                    errors.append(f"Multiple segments titled '{segment_title}' found. Please ensure titles are unique if intended.")
                    status = 'error'
        
        except Exception as e:
            errors.append(f"Error processing segment core '{segment_title}': {str(e)}")
            status = 'error'
        
        if not instance or status == 'error':
            # If segment creation/retrieval failed, return immediately
            return {'instance': instance, 'status': status if status == 'error' else 'error', 'errors': errors}

        # --- Set the M2M relationship for products ---
        # This happens if the segment instance was successfully created, updated, or found (and update_existing is true for M2M).
        if products_input_data is not None and (status in ['created', 'updated'] or (status == 'skipped' and self.update_existing)):
            try:
                # .set() handles clearing existing and adding new.
                # If product_instances_to_set is empty and products_input_data was an empty list,
                # this will clear the M2M relationship.
                instance.products.set(product_instances_to_set)
            except Exception as m2m_e:
                errors.append(f"Error setting products for segment '{segment_title}': {str(m2m_e)}")
                # If M2M fails, the overall status might need adjustment

        final_status = status
        # If there were any errors (either from segment core or product resolution/M2M)
        # and the segment wasn't an outright error or skipped without issue, mark as completed with errors.
        if errors and status not in ['error', 'skipped']: 
            final_status = 'completed_with_errors'
        
        return {'instance': instance, 'status': final_status, 'errors': errors}
